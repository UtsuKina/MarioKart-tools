<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>マップ（ズーム・パン対応／保存付）</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --sc-bg:#1e66ff; --nisc-bg:#e53935; --itembox-bg:#ff9800;
  }
  *{box-sizing:border-box}
  body{margin:0;display:flex;font-family:sans-serif;background:#fafafa;color:#222;height:100vh;}

  #map-wrap{flex:1;display:flex;flex-direction:row;align-items:stretch;}


#map-area {
  flex: 1;
  position: relative;
  background: #fff;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: grab;
border: 2px solid #000;
}



#map-area.capture-border {
  outline: 3px dashed rgba(0,0,0,0.6);
  outline-offset: -3px;
}


body {
  background: #eee;
}





  #map-area.dragging{cursor:grabbing;}

  #map-inner{
    position:relative;
  overflow: visible;
    transform-origin:center center;
  }
  #map-inner img{
    display:block; max-width:100%; max-height:100%;
    user-select:none; -webkit-user-drag:none; pointer-events:none;
  }
  svg.arrow-layer{
    position:absolute; top:0; left:0; width:100%; height:100%;
    pointer-events:auto;

 overflow: visible;

  }



#arrow-layer {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none; /* 矢印自体はクリックを通す */
}

.arrow-line {
  position: absolute;
  height: 3px; /* 線の太さ */
  transform-origin: 0 50%;
  pointer-events: auto;

  cursor: move; 

}

.arrow-line::after {
  content: "";
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%) rotate(45deg);
  width: 6px;
  height: 6px;
  border-top: 3px solid currentColor;
  border-right: 3px solid currentColor;
}

/* 矢印線の当たり判定を広げる（透明な領域） */
.arrow-line::before {
  content: "";
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 100%;
  height: 16px;     /* ← クリックできる範囲を広げる。好みに応じて調整（例：20px） */
  cursor: move;
}



#zoomDisplay {
  position:absolute;
  top:8px;
  right:8px;
  background:rgba(0,0,0,0.6);
  color:#fff;
  font-size:12px;
  padding:2px 6px;
  border-radius:4px;
  pointer-events:none;
}


#sidebar { display:flex; flex-direction:column; }
.sidebar-scroll { flex:1; overflow-y:auto; }



  #sidebar{
    width:220px; border-left:1px solid #ddd; background:#fff; overflow-y:auto;
  }
  #sidebar h3{margin:10px 8px 6px;font-size:13px;color:#444}

  .icons{display:flex;flex-wrap:wrap;gap:6px;padding:0 8px 8px;}

.icon {
  width:24px;
  height:24px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:800;
  font-size:12px;   /* マップに合わせる */
  color:#fff;
  margin:0;         /* 余白を消す */
  cursor:grab;
  user-select:none;




}

  .sc{border-radius:50%;background:var(--sc-bg);}
  .nisc{border-radius:50%;background:var(--nisc-bg);}
  .itembox{border-radius:6px;background:var(--itembox-bg);}


.icon.item {
  width:24px;
  height:24px;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
}

.placed.item {
  width:24px;
  height:24px;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
}


/* マップ上のアイコンを一回り小さくし、中心基準にする */

.text-label {
  position: absolute;
  min-width: 40px;
  min-height: 20px;
  font-size: 14px;
  background: rgba(255,255,255,0.7);
  border: 1px solid #ccc;
  padding: 2px 4px;
  border-radius: 3px;
  cursor: move;


  white-space: nowrap;
  outline: none;
  user-select: text;


}


.placed {
  position:absolute;
  cursor:move;
  width:24px;
  height:24px;
  display:flex;
  align-items:center;
  justify-content:center;
  text-align:center;    /* ★追加 */
  line-height:24px;     /* ★追加：高さに合わせる */
  font-weight:800;
  font-size:12px;
  color:#fff;
  transform: translate(-50%, -50%);
}



  .placed.sc{background:var(--sc-bg);border-radius:50%;}
  .placed.nisc{background:var(--nisc-bg);border-radius:50%;}
  .placed.itembox{background:var(--itembox-bg);border-radius:6px;}

  #legend{margin:8px;padding:8px;border-top:1px solid #eee;font-size:12px;background:rgba(255,255,255,.9)}
  .hint{font-size:11px;color:#666;margin-top:6px}


  .arrow-hit{stroke:black; stroke-opacity:0; stroke-width:32;   stroke-linecap:round; pointer-events:stroke;}
  .arrow-vis{stroke-width:3; pointer-events:none;}
  .arrow-group{cursor:move;}
  .start-dot{
    position:absolute;width:10px;height:10px;border-radius:50%;
    background:#000;transform:translate(-50%,-50%); pointer-events:none; opacity:.6;



  }


.hide-icons .placed,
.hide-icons .text-label,
.hide-icons .arrow-line {
  visibility: hidden;   /* ← これで非表示。位置は保持される */
}

/* 選択中の矢印ボタンを分かりやすくする */
.arrow-btn.active-arrow {
  background-color: #ccc;
  box-shadow: inset 0 0 4px rgba(0,0,0,0.4);
}



button { 
  margin: 4px 2px;  /* ← 8px を 4px にすると間隔が半分になる */
  padding:6px 12px;
  font-size:13px;
  border:1px solid #888;
  border-radius:6px;
  background:#eee;
  cursor:pointer;
  height:28px;
  line-height:1;
}


#resizer-map {
  width: 6px;
  cursor: col-resize;
  background: #ccc;
  transition: background 0.2s;
}
#resizer-map:hover {
  background: #999;
}



</style>
</head>
<body>
<div id="map-wrap">



  <div id="map-area">
    <div id="map-inner">
      <img id="bgimg" src="" alt="map">
     <div id="arrow-layer"></div>
    </div>

<div id="zoomDisplay">1.0x</div>

  </div>

  <div id="resizer-map"></div>

  <aside id="sidebar">
<div class="sidebar-top">

<!-- 既存のボタン群の近くに追加 -->
<div style="padding:8px;">
  <div>アイコンサイズ</div>
  <input type="range" id="iconSizeRange" min="0.5" max="2.0" step="0.1" value="1.0">
  <span id="iconSizeValue">1.0x</span>
</div>
 </div>

  <div class="sidebar-scroll">


    <h3>SC</h3><div id="sc-icons" class="icons"></div>
    <h3>NISC</h3><div id="nisc-icons" class="icons"></div>
    <h3>ItemBox</h3><div id="item-icons" class="icons"></div>

<h3>Item</h3><div id="items" class="icons"></div>

  </div>


  <div class="sidebar-bottom">

<button id="textBtn" draggable="true">T</button>

<button id="blackArrowBtn" title="黒矢印">↗</button>
<button id="blueArrowBtn" title="青矢印" style="color:blue;">↗</button>
<button id="redArrowBtn" title="赤矢印" style="color:red;">↗</button>

<button id="resetZoomBtn">1.0x</button>

<button id="fitBtn">最適サイズ</button>


<button id="toggleIconsBtn">アイコン非表示</button>


<button id="undoBtn">↻</button>
<button id="redoBtn">↺</button>
<button id="clearBtn">🗑️全削除</button>
<button id="exportBtn">💾PNG保存</button>

<button id="replaceItemBoxBtn">ItemBox → IB変換</button>


    <div id="legend">
      <div>・Tボタンをドラッグ&ドロップで文字入力。ダブルクリックで再編集</div>
      <div>・右クリックで削除</div>
      <div>・マップを2回クリックで矢印の始点と終点を決定</div>
      <div>・ドラッグで移動</div>
      <div>・ドラッグでマップ移動</div>
      <div>・ホイールでズーム（0.5x〜3x）</div>
    </div>

 </div>

  </aside>
</div>

<script>
const params=new URLSearchParams(location.search);
const START=params.get("start")||""; const END=params.get("end")||"";
const STORAGE_KEY=`map_${START}_${END}`;

const mapArea=document.getElementById('map-area');
const mapInner=document.getElementById('map-inner');
const img=document.getElementById('bgimg');

const arrowLayer=document.getElementById('arrow-layer');

const sidebar=document.getElementById('sidebar');


let currentArrowColor = "black"; // デフォルト

// 矢印ボタン一覧（3色）
const arrowButtons = [
  {id: "blackArrowBtn", color: "black"},
  {id: "redArrowBtn",   color: "red"},
  {id: "blueArrowBtn",  color: "blue"}
];

// 各ボタンに共通クラスを付与
arrowButtons.forEach(btn=>{
  const el = document.getElementById(btn.id);
  el.classList.add("arrow-btn");
  el.addEventListener("click", ()=>{
    currentArrowColor = btn.color;

    // 一度全てリセット
    arrowButtons.forEach(b=>{
      document.getElementById(b.id).classList.remove("active-arrow");
    });

    // 選択中ボタンにハイライト付与
    el.classList.add("active-arrow");
  });
});

// デフォルト（黒矢印）を選択状態に
document.getElementById("blackArrowBtn").classList.add("active-arrow");



let zoom=1, panX=0, panY=0; // 表示変換の状態
let dragTarget=null, offsetX=0, offsetY=0;
let isDraggingSomething=false;
let arrowStartPoint=null, startDot=null;


// 基準サイズは固定
const baseIconSizes = {
  SC: 24,
  NISC: 24,
  ItemBox: 24,
  item: 24
};

// スライダーで変わる倍率（初期値1.0）
let iconScale = 1.0;

function applyIconSizesToDOM(){
  document.querySelectorAll('.placed').forEach(el=>{
    const t = el.dataset.type;
    const base = baseIconSizes[t] || 24;
    const size = Math.round(base * iconScale);
    el.style.width = size + 'px';
    el.style.height = size + 'px';
  });

  document.querySelectorAll('.icon').forEach(el=>{
    const t = el.dataset.type;
    if(!t) return;
    const base = baseIconSizes[t] || 24;
    const size = Math.round(base * iconScale);
    el.style.width = size + 'px';
    el.style.height = size + 'px';
  });
}

// スライダーのイベントは外で1回だけ
document.getElementById('iconSizeRange').addEventListener('input', e=>{
  iconScale = parseFloat(e.target.value);
  applyIconSizesToDOM();
  localStorage.setItem(`iconScale_${STORAGE_KEY}`, iconScale); // ←コースごと保存！
  document.getElementById("iconSizeValue").textContent = iconScale.toFixed(1) + "x";
});





/* パレット初期化 */
function createPalette(cid,type,cls){
  const c=document.getElementById(cid); c.innerHTML="";
  for(let i=1;i<=12;i++){
    const d=document.createElement("div");
    d.className="icon "+cls;
    d.draggable=true; d.dataset.type=type; d.dataset.num=i; d.textContent=i;
    c.appendChild(d);
  }
}
createPalette("sc-icons","SC","sc");
createPalette("nisc-icons","NISC","nisc");
createPalette("item-icons","ItemBox","itembox");




// ★ここでパレット側にもサイズ補正を適用
applyIconSizesToDOM();


// ページロード時にアイコンサイズ倍率を復元（コースごと）
const storedScale = localStorage.getItem(`iconScale_${STORAGE_KEY}`);
if (storedScale) {
  iconScale = parseFloat(storedScale);
  document.getElementById("iconSizeRange").value = iconScale;
  document.getElementById("iconSizeValue").textContent = iconScale.toFixed(1) + "x";
  applyIconSizesToDOM();
}



</script>
<script src="courses.js"></script>
<script>
const bg=(typeof getBackground==="function"?getBackground(START,END):"")||(typeof defaultBackground!=="undefined"?defaultBackground:"");
if(bg) img.src=bg;


</script>
<script>

/* ===== パン・ズーム管理 ===== */
function applyTransform(){
  mapInner.style.transform=`translate(${panX}px,${panY}px) scale(${zoom})`;
 document.getElementById("zoomDisplay").textContent = zoom.toFixed(1) + "x";
}
mapArea.addEventListener('wheel',e=>{
  if(e.target.closest('#sidebar')) return;
  e.preventDefault();
  const scale=e.deltaY<0?1.1:0.9;
  zoom*=scale; zoom=Math.max(0.5,Math.min(zoom,3));
  applyTransform();
});
let panDragging=false, panPrev={x:0,y:0};
  mapArea.addEventListener('mousedown',e=>{
   if(e.button !== 1) return; // 中ボタン以外は無視
   if(e.target.closest('#sidebar')) return; // サイドバー上は無視
   panDragging=true; panPrev={x:e.clientX,y:e.clientY};
   mapArea.classList.add('dragging');
   e.preventDefault(); // 中クリックのスクロール動作を抑制
});
document.addEventListener('mousemove',e=>{
  if(!panDragging) return;
  const dx=e.clientX-panPrev.x, dy=e.clientY-panPrev.y;
  panX+=dx; panY+=dy;
  panPrev={x:e.clientX,y:e.clientY};
  applyTransform();
});
document.addEventListener('mouseup',()=>{
  panDragging=false; mapArea.classList.remove('dragging');
});
document.getElementById('resetZoomBtn').addEventListener('click',()=>{
  zoom=1; panX=0; panY=0; applyTransform();
});


// ウィンドウリサイズ時に全矢印の位置を再計算
window.addEventListener('resize', ()=>{
  document.querySelectorAll('.arrow-line').forEach(applyArrowLinePosition);
});





/* ===== D&D（sidebar → map-inner にドロップ） ===== */
mapArea.addEventListener('dragover', e => e.preventDefault());
mapArea.addEventListener('drop', e => {
  e.preventDefault();
  const type=e.dataTransfer.getData("type");
  const num =e.dataTransfer.getData("num");
  if(!type || !num) return;

  // ★ Item 以外は重複禁止
  if (type !== 'item' &&
      mapInner.querySelector(`.placed[data-type="${type}"][data-num="${num}"]`)) {
    return;
  }

  const rect=mapInner.getBoundingClientRect();
  const xp=((e.clientX-rect.left)/rect.width )*100;
  const yp=((e.clientY-rect.top )/rect.height)*100;

  const icon=createPlacedIcon(type,num,xp,yp);
  mapInner.appendChild(icon);


// ここで即サイズ調整
applyIconSizesToDOM();



  // ★ Item 以外はパレットから消す
  if (type !== 'item') {
    removeFromPalette(type,num);
  }

  saveState();
});


// ---- テキスト(Tボタン)のドラッグ＆ドロップ ----
sidebar.addEventListener('dragstart', e=>{
  if(e.target.id === "textBtn"){
    e.dataTransfer.setData("type", "text");
  }
});

mapArea.addEventListener('drop', e=>{
  e.preventDefault();
  const type = e.dataTransfer.getData("type");
  if(type === "text"){
    const rect = mapInner.getBoundingClientRect();
    const xp=((e.clientX-rect.left)/rect.width )*100;
    const yp=((e.clientY-rect.top )/rect.height)*100;

const label = createTextLabel("", xp, yp, "#000", true);



    saveState();
    return;
  }
  // 既存のアイコン処理はそのまま残す
});




let iconsHidden = false;
const toggleBtn = document.getElementById("toggleIconsBtn");

toggleBtn.addEventListener("click", ()=>{
  iconsHidden = !iconsHidden;

  if(iconsHidden){
    mapInner.classList.add("hide-icons");
  }else{
    mapInner.classList.remove("hide-icons");
  }

  toggleBtn.textContent = iconsHidden ? "アイコン表示" : "アイコン非表示";
});







// アンドゥ/リドゥ
let history = [], historyIndex = -1;





document.getElementById("undoBtn").addEventListener("click", ()=>{
  if(historyIndex>0){
    historyIndex--;
    loadStateFromString(history[historyIndex]);
    localStorage.setItem(STORAGE_KEY, history[historyIndex]); // ← これ追加
  }
});
document.getElementById("redoBtn").addEventListener("click", ()=>{
  if(historyIndex < history.length-1){
    historyIndex++;
    loadStateFromString(history[historyIndex]);
    localStorage.setItem(STORAGE_KEY, history[historyIndex]); // ← これ追加
  }
});






// 最適サイズボタン
let fitZoom = 1;
img.addEventListener('load', ()=>{
  const areaRect = mapArea.getBoundingClientRect();
  fitZoom = Math.min(areaRect.width / img.naturalWidth, areaRect.height / img.naturalHeight);
});
document.getElementById("fitBtn").addEventListener("click", ()=>{
  zoom = fitZoom * 0.95;
  panX=0; panY=0;
  applyTransform();
});






// PNG出力
document.getElementById("exportBtn").addEventListener("click", ()=>{
  const prevBorder = mapArea.style.border;
  mapArea.style.border = "none";  // 一時的に消す
  html2canvas(mapArea, {useCORS:true, backgroundColor:null}).then(canvas=>{
    const a = document.createElement("a");
    a.href = canvas.toDataURL("image/png");
    a.download = "map.png";
    a.click();
  }).finally(()=>{
    mapArea.style.border = prevBorder; // 元に戻す
  });
});





sidebar.addEventListener('dragstart',e=>{
  if(e.target.classList.contains("icon")){
    e.dataTransfer.setData("type",e.target.dataset.type);
    e.dataTransfer.setData("num", e.target.dataset.num);
  }
});



/* ===== アイコン生成・移動・削除 ===== */
function createPlacedIcon(type,num,xPercent,yPercent){
  const icon=document.createElement("div");
  icon.classList.add("placed", type.toLowerCase());
  icon.dataset.type=type;
  icon.dataset.num =num;

  if(type === "item"){
    icon.style.backgroundImage = `url('item_images/${num}.png')`;
    icon.style.backgroundSize = 'contain';
    icon.style.backgroundRepeat = 'no-repeat';
    icon.style.backgroundPosition = 'center';
  }else{
    icon.textContent = num;
  }

  setIconPos(icon, xPercent, yPercent);
  icon.addEventListener('mousedown',startDragIcon);

  icon.addEventListener('contextmenu',e=>{
    e.preventDefault();
    icon.remove();
    if (type !== 'item') restoreToPalette(type,num);
    saveState();
  });

  // ★ ここでサイズを現在の scale に合わせる
  applyIconSizesToDOM();

  return icon;
}


/* ===== 統一：保存／復元（undo/redo + localStorage） ===== */


function saveState(){
  const state = {
    icons: [...mapInner.querySelectorAll('.placed')].map(el=>({
      type: el.dataset.type,
      num: el.dataset.num,
      xp: +el.dataset.xp,
      yp: +el.dataset.yp
    })),



arrowLines: [...document.querySelectorAll('.arrow-line')].map(d => ({
  x1p:+d.dataset.x1p, y1p:+d.dataset.y1p,
  x2p:+d.dataset.x2p, y2p:+d.dataset.y2p,
  color:d.style.backgroundColor
})),




texts: [...mapInner.querySelectorAll('.text-label')].map(el=>({
  xp:+el.dataset.xp,   // ← dataset の % を必ず使う
  yp:+el.dataset.yp,
  html: el.innerHTML   // ← innerText → innerHTML
})),



  };

  const s = JSON.stringify(state);

  // 直前の履歴と同じなら重複 push しない（無駄な履歴増加防止）
  if(historyIndex >= 0 && history[historyIndex] === s) {
    localStorage.setItem(STORAGE_KEY, s);
    return;
  }

  history = history.slice(0, historyIndex+1);
  history.push(s);
  historyIndex++;
  // 現在状態は localStorage にも入れておく（ページ再読み込み時の復元用）
  localStorage.setItem(STORAGE_KEY, s);
}

/* loadStateFromString: 履歴文字列から復元（undo/redo 用に使う） */
function loadStateFromString(stateStr){
  // 既存の配置を消す
  [...mapInner.querySelectorAll('.placed')].forEach(el=>el.remove());

[...document.querySelectorAll('.arrow-line')].forEach(g=>g.remove());


  [...mapInner.querySelectorAll('.text-label')].forEach(t=>t.remove());

  if(!stateStr) return;
  try{
    const s = JSON.parse(stateStr);

    for(const it of (s.icons||[])){
      const el = createPlacedIcon(it.type, it.num, it.xp, it.yp);
      mapInner.appendChild(el);
      if (it.type !== 'item') removeFromPalette(it.type, it.num);
    }

for(const a of (s.arrowLines || s.arrows || [])){
  createArrowLine(a.x1p, a.y1p, a.x2p, a.y2p, a.color || "black");
}


for(const t of (s.texts||[])){
  const div = createTextLabel("", t.xp, t.yp); // 位置だけ指定して作成
  div.innerHTML = t.html || "";                // ← 保存時に innerHTML を持たせたので復元
}




  }catch(e){
    console.warn("loadStateFromString parse error", e);
  }
}

/* loadState: ページ読み込み時の localStorage からの復元 + history 初期化 */
function loadState(){
  const raw = localStorage.getItem(STORAGE_KEY);
  history = []; historyIndex = -1;

  if(!raw) return;
  try{
    const s = JSON.parse(raw);

    // 既存をクリア（念のため）
    [...mapInner.querySelectorAll('.placed')].forEach(el=>el.remove());
[...document.querySelectorAll('.arrow-line')].forEach(g=>g.remove());

    [...mapInner.querySelectorAll('.text-label')].forEach(t=>t.remove());

    for(const it of (s.icons||[])){
      const el = createPlacedIcon(it.type, it.num, it.xp, it.yp);
      mapInner.appendChild(el);
      if (it.type !== 'item') removeFromPalette(it.type, it.num);
    }

   for(const a of (s.arrowLines || s.arrows || [])){
  createArrowLine(a.x1p, a.y1p, a.x2p, a.y2p, a.color || "black");
}


for(const t of (s.texts||[])){
  const div = createTextLabel("", t.xp, t.yp); // 位置だけ指定して作成
  div.innerHTML = t.html || "";                // ← 保存時に innerHTML を持たせたので復元
}



    // アイコンサイズが保存されていれば復元
if(s.iconScale !== undefined){
  iconScale = s.iconScale;
  document.getElementById("iconSizeRange").value = iconScale;
  document.getElementById("iconSizeValue").textContent = iconScale.toFixed(1) + "x";

}
applyIconSizesToDOM();





    // history 初期化（undo の基点）
const stateStr = JSON.stringify({
  icons: s.icons || [],
  arrowLines: s.arrowLines || s.arrows || [],
  texts: s.texts || []
});

    history = [stateStr];
    historyIndex = 0;

  }catch(e){
    console.warn('loadState parse error', e);
  }
}





function setIconPos(el, xp, yp){
  el.style.left = xp + "%";
  el.style.top  = yp + "%";
  el.dataset.xp = xp;
  el.dataset.yp = yp;
}
function startDragIcon(e){
if (e.button !== 0) return; // ★左クリック以外は無視
  dragTarget=e.target;
  isDraggingSomething=true;
  const rect=dragTarget.getBoundingClientRect();
  offsetX=e.clientX-rect.left;
  offsetY=e.clientY-rect.top;
  document.addEventListener('mousemove',onDragIcon);
  document.addEventListener('mouseup',endDragIcon);
}
function onDragIcon(e){
  if(!dragTarget)return;
  e.preventDefault();
  const rect=mapInner.getBoundingClientRect();
  const x=((e.clientX-rect.left-offsetX)/rect.width )*100;
  const y=((e.clientY-rect.top -offsetY)/rect.height)*100;
  setIconPos(dragTarget, x, y);
}
function endDragIcon(){
  document.removeEventListener('mousemove',onDragIcon);
  document.removeEventListener('mouseup',endDragIcon);
  setTimeout(()=>{ isDraggingSomething=false; saveState(); },50);
}

function getMapPercentPoint(e) {
  const rect = mapInner.getBoundingClientRect();
  return {
    xp: ((e.clientX - rect.left) / rect.width) * 100,
    yp: ((e.clientY - rect.top ) / rect.height) * 100
  };
}


/* --- アイテムパレットを作成（既存の #items に追加）--- */
(function createItemPalette(){
  const itemList = [
    {name:'kino1', title:'キノ1'},
    {name:'kino2', title:'キノ2'},
    {name:'kino3', title:'キノ3'},
    {name:'star',  title:'スター'},
    {name:'Gkino', title:'金キノ'},
    {name:'killer',title:'キラー'},   // ← killer.png
    {name:'hane',  title:'ハネ'},
    {name:'thunder', title:'サンダー'},
    {name:'IB',    title:'アイテムボックス'}, // ← IB.png にリネーム済み
　　{name:'DoubleIB',    title:'ダブルアイテムボックス'},
    {name:'food',  title:'フード'}   // ← food.png


  ];

  const container = document.getElementById('items');
  if(!container) return;

  container.innerHTML = '';

  itemList.forEach(it=>{
    const d = document.createElement('div');
    d.className = 'icon item';
    d.dataset.type = 'item';
    d.dataset.num  = it.name;
    d.title = it.title;
    d.style.backgroundImage = `url('item_images/${it.name}.png')`;
    d.style.backgroundSize = 'contain';
    d.style.backgroundRepeat = 'no-repeat';
    d.style.backgroundPosition = 'center';
    d.setAttribute('draggable','true');
    container.appendChild(d);
  });
})();


/* ===== テキスト入力機能 ===== */
mapArea.addEventListener("dblclick", e => {
  if(e.target.closest("#sidebar")) return; // サイドバー上は無視
  if(e.target.closest(".placed") || e.target.closest(".text-label")) return; // アイコンや既存ラベルは無視

  const {xp, yp} = getMapPercentPoint(e);
    createTextLabel("テキスト", xp, yp);
  saveState();
});




function createTextLabel(text, xPercent, yPercent, color="#000", autoFocus=false) {
  const div = document.createElement("div");
  div.className = "text-label";
  div.textContent = text || "";
  div.dataset.xp = +xPercent;
  div.dataset.yp = +yPercent;
  div.style.color = color;

  // 初期位置
  setIconPos(div, +xPercent, +yPercent);

  // 移動
  div.addEventListener("mousedown", e => {
    if (e.button !== 0) return;
    dragTarget = div;
    isDraggingSomething = true;
    const rect = dragTarget.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;
    document.addEventListener("mousemove", onDragIcon);
    document.addEventListener("mouseup", endDragIcon);
  });

  // 右クリックで削除
  div.addEventListener("contextmenu", e => {
    e.preventDefault();
    div.remove();
    saveState();
  });

  // ダブルクリックで編集再開
  div.addEventListener("dblclick", e => {
    e.stopPropagation();
    div.contentEditable = true;
    div.focus();
  });

  // Enterで確定、Shift+Enterは改行
  div.addEventListener("keydown", e => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      div.contentEditable = false;
      div.blur();
      saveState();
    }
  });

  // フォーカス外れたら確定
  div.addEventListener("blur", () => {
    if (div.isContentEditable) {
      div.contentEditable = false;
      saveState();
    }
  });

  mapInner.appendChild(div);

  // ★ 新規作成の時だけオートフォーカス
  if(autoFocus){
    div.contentEditable = true;
    setTimeout(() => div.focus(), 0);
  }

  return div;
}




/* ===== 矢印管理 ===== */
mapArea.addEventListener('click', e=>{
  if(isDraggingSomething) return;
  if(e.target.closest('#sidebar')) return;
  if(e.target.closest('.placed')) return;

  // ★クリック位置をズーム・パン補正して取得
  const {xp, yp} = getMapPercentPoint(e);

  if(!arrowStartPoint){
    arrowStartPoint={xp, yp};
    startDot=document.createElement('div');
    startDot.className='start-dot';
    startDot.style.left=xp+"%"; startDot.style.top=yp+"%";
    mapInner.appendChild(startDot);
  }else{

   createArrowLine(arrowStartPoint.xp, arrowStartPoint.yp, xp, yp);


    arrowStartPoint=null;
    if(startDot){ startDot.remove(); startDot=null; }
    saveState();
  }
});








function createArrowLine(x1p, y1p, x2p, y2p, color = currentArrowColor) {
  const div = document.createElement("div");
  div.className = "arrow-line";
  div.style.backgroundColor = color;
  div.style.color = color;
  div.dataset.x1p = x1p;
  div.dataset.y1p = y1p;
  div.dataset.x2p = x2p;
  div.dataset.y2p = y2p;

  applyArrowLinePosition(div);

  // 右クリックで削除
  div.addEventListener("contextmenu", e => {
    e.preventDefault();
    div.remove();
    saveState();
  });

  // ▼ 左クリックドラッグで矢印全体を移動
  let dragging = false;
  let prev = null;

  div.addEventListener("mousedown", e => {
    if (e.button !== 0) return; // 左クリックのみ
    dragging = true;
    isDraggingSomething = true;
    prev = getRelPercentPoint(e);
    e.preventDefault();
  });

  document.addEventListener("mousemove", e => {
    if (!dragging) return;
    const p = getRelPercentPoint(e);
    const dx = p.x - prev.x;
    const dy = p.y - prev.y;

    // dataset座標を更新
    div.dataset.x1p = +div.dataset.x1p + dx;
    div.dataset.y1p = +div.dataset.y1p + dy;
    div.dataset.x2p = +div.dataset.x2p + dx;
    div.dataset.y2p = +div.dataset.y2p + dy;

    prev = p;
    applyArrowLinePosition(div);
  });

  document.addEventListener("mouseup", () => {
    if (dragging) {
      dragging = false;
      setTimeout(() => {
        isDraggingSomething = false;
        saveState();
      }, 50);
    }
  });

  document.getElementById("arrow-layer").appendChild(div);
  return div;
}


function applyArrowLinePosition(div) {
  const baseW = mapInner.clientWidth;
  const baseH = mapInner.clientHeight;

  const x1 = (div.dataset.x1p / 100) * baseW;
  const y1 = (div.dataset.y1p / 100) * baseH;
  const x2 = (div.dataset.x2p / 100) * baseW;
  const y2 = (div.dataset.y2p / 100) * baseH;

  const dx = x2 - x1;
  const dy = y2 - y1;
  const len = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx) * 180 / Math.PI;

  div.style.left = x1 + "px";
  div.style.top = y1 + "px";
  div.style.width = len + "px";
  div.style.transform = `rotate(${angle}deg)`;
}





function getRelPercentPoint(e){
 const rect = mapInner.getBoundingClientRect(); // ★修正
  return { x: ((e.clientX - rect.left) / rect.width ) * 100,
           y: ((e.clientY - rect.top  ) / rect.height) * 100 };
}





/* ===== パレット表示制御 ===== */
function removeFromPalette(type,num){
  const el=sidebar.querySelector(`.icon[data-type="${type}"][data-num="${num}"]`);
  if(el) el.style.visibility="hidden";
}
function restoreToPalette(type,num){
  const el=sidebar.querySelector(`.icon[data-type="${type}"][data-num="${num}"]`);
  if(el) el.style.visibility="visible";
}
function restoreAllPalette(){
  sidebar.querySelectorAll('.icon').forEach(el=>el.style.visibility="visible");
}








document.getElementById('clearBtn').addEventListener('click',()=>{
  [...mapInner.querySelectorAll('.placed')].forEach(el=>el.remove());
[...document.querySelectorAll('.arrow-line')].forEach(g=>g.remove());
  [...mapInner.querySelectorAll('.text-label')].forEach(el=>el.remove()); 
  restoreAllPalette();
  localStorage.removeItem(STORAGE_KEY);
});


img.addEventListener('load', ()=>{
  const iw = img.naturalWidth;
  const ih = img.naturalHeight;

// 矢印レイヤーを画像と同じ大きさに固定（div の style を使う）
arrowLayer.style.width  = iw + "px";
arrowLayer.style.height = ih + "px";


  // 最大フィット倍率を計算
  const areaRect = mapArea.getBoundingClientRect();
  const fitZoom = Math.min(areaRect.width / iw, areaRect.height / ih);

  zoom = fitZoom * 0.95;
  panX = 0;
  panY = 0;

  applyTransform();
  loadState();

});


sidebar.addEventListener('dragstart',e=>{
  if(e.target.classList.contains('icon')){
    e.dataTransfer.setData('type', e.target.dataset.type);
    e.dataTransfer.setData('num',  e.target.dataset.num);
  }
});


/* ===== ItemBox → IB置き換えボタン ===== */
document.getElementById("replaceItemBoxBtn").addEventListener("click", ()=>{
  const boxes = [...mapInner.querySelectorAll('.placed.itembox')];
  if (!boxes.length) return;

  // 履歴に保存（Undo対応）
  saveState();

  boxes.forEach(box => {
    const xp = +box.dataset.xp;
    const yp = +box.dataset.yp;
    const num = box.dataset.num;

    // IBアイコン生成
    const ib = createPlacedIcon("item", "IB", xp, yp);
    mapInner.appendChild(ib);

    restoreToPalette("ItemBox", num);
    box.remove();
  });

  // 更新後の状態も履歴に記録
  saveState();
});



const resizerMap = document.getElementById("resizer-map");
let startX2 = 0, startWidth2 = 0;
resizerMap.addEventListener("pointerdown", e => {
  e.preventDefault();
  startX2 = e.clientX;
  startWidth2 = sidebar.offsetWidth;
  resizerMap.setPointerCapture(e.pointerId);
  document.body.style.cursor = "col-resize";
});
resizerMap.addEventListener("pointermove", e => {
  if (!resizerMap.hasPointerCapture(e.pointerId)) return;
  const dx = startX2 - e.clientX;
  const newW = Math.min(Math.max(startWidth2 + dx, 150), 400);
  sidebar.style.width = newW + "px";
});
resizerMap.addEventListener("pointerup", e => {
  if (resizerMap.hasPointerCapture(e.pointerId))
    resizerMap.releasePointerCapture(e.pointerId);
  document.body.style.cursor = "";
  localStorage.setItem("mapSidebarWidth", sidebar.offsetWidth);
});
// 再読み込み時に幅復元
const savedSidebarWidth = localStorage.getItem("mapSidebarWidth");
if (savedSidebarWidth) sidebar.style.width = savedSidebarWidth + "px";


</script>

<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>


</body>
</html>
